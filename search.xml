<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>stream流简单应用</title>
    <url>/2020/03/01/stream/</url>
    <content><![CDATA[<p>jdk13已经发布了，许多小伙伴连jdk8都没摸透，笔者在这里简单向各位介绍下jdk8中的一些api，这些也是笔者在实际工作中用到的，如有疏漏，请多海涵。</p>
<p>如果各位同学想要学习可以先知道基本用法，留个印象，在遇到时就百度，多遇到几次自然会记住，死记硬背只能徒增痛苦，</p>
<p>java中主要新加了stream流式编程与lambda表达式，lambda主要简化了一些写法，stream则提供了一些方法是编程人员能更方便的处理数据。话不多说我们主要来看具体的应用。</p>
<a id="more"></a>
<h3 id="场景一：把list转为map，对象中的id作为key，对象作为value"><a href="#场景一：把list转为map，对象中的id作为key，对象作为value" class="headerlink" title="场景一：把list转为map，对象中的id作为key，对象作为value"></a>场景一：把list转为map，对象中的id作为key，对象作为value</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map &lt;String,Object&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">for(Object o:list)&#123;</span><br><span class="line">    map.put(o.getid(),o);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是在java8前，大家肯定都会像上面这样写，但这样写不够优雅，在java8 后我们可以更方便的写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; list.stream().collect(Collectors.toMap(Object::getId, Obejct));</span><br></pre></td></tr></table></figure>
<p>这样一行就可以搞定，可读性高。</p>
<h3 id="场景二：计算list中属性和"><a href="#场景二：计算list中属性和" class="headerlink" title="场景二：计算list中属性和"></a>场景二：计算list中属性和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">heji.setFee(feeList.stream().map(i-&gt;i.getFee()).reduce((float)0, (a, b) -&gt; a + b));</span><br></pre></td></tr></table></figure>
<h3 id="场景三：获取学生专业的部门信息"><a href="#场景三：获取学生专业的部门信息" class="headerlink" title="场景三：获取学生专业的部门信息"></a>场景三：获取学生专业的部门信息</h3><p>使用option可以很方便的判断null值，并设置默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(student.getMajor())</span><br><span class="line">    .map(i-&gt;i.getDepartment())</span><br><span class="line">    .map(i-&gt;i.getName())</span><br><span class="line">    .orElse(&quot;&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="场景四：判断list中join属性是否为空，不为空则将其设置至实体中"><a href="#场景四：判断list中join属性是否为空，不为空则将其设置至实体中" class="headerlink" title="场景四：判断list中join属性是否为空，不为空则将其设置至实体中"></a>场景四：判断list中join属性是否为空，不为空则将其设置至实体中</h3><p>==Optional判断list时无法判断size为0的情况，所以要加上filter==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(enrollmentList)</span><br><span class="line">        .filter(i -&gt; i.size() !&#x3D; 0)</span><br><span class="line">        .map(i -&gt; i.get(0))</span><br><span class="line">        .map(i -&gt; i.getJoin())</span><br><span class="line">        .ifPresent(</span><br><span class="line">                join -&gt; &#123;</span><br><span class="line">                    xgStudent.setJoinName(join.getJoinName());</span><br><span class="line">                    xgStudent.setJoinForm(join.getId());</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<h3 id="场景五-获取teacherList的教师姓名列表"><a href="#场景五-获取teacherList的教师姓名列表" class="headerlink" title="场景五:获取teacherList的教师姓名列表"></a>场景五:获取teacherList的教师姓名列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xgStudentService.getTeacherList(teacherids).stream()</span><br><span class="line">.map(t -&gt; t.getName())</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="场景六：获取list的id并将其拼接"><a href="#场景六：获取list的id并将其拼接" class="headerlink" title="场景六：获取list的id并将其拼接"></a>场景六：获取list的id并将其拼接</h3><p>==从左至右为分隔符，前缀，后缀==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">professionalList.stream()</span><br><span class="line">        .map(i -&gt; i.getId())</span><br><span class="line">        .collect(Collectors.joining(&quot;&#39;,&#39;&quot;, &quot;&#39;&quot;, &quot;&#39;&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="场景七：将departList按id去重并返回list"><a href="#场景七：将departList按id去重并返回list" class="headerlink" title="场景七：将departList按id去重并返回list"></a>场景七：将departList按id去重并返回list</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">depart.stream().filter(i-&gt;StringUtils.isNotBlank(i.getName())).collect(</span><br><span class="line">        collectingAndThen(</span><br><span class="line">                toCollection(() -&gt; new TreeSet&lt;&gt;(comparing(n -&gt; n.getId()))), ArrayList::new));</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令</title>
    <url>/2020/02/27/linux/</url>
    <content><![CDATA[<p><strong>常用Linux命令</strong></p>
<p>本文记录了一些常用的linux命令</p>
<a id="more"></a>
<p>cd</p>
<ul>
<li>cd /root/Docements # 切换到目录/root/Docements</li>
<li>cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录</li>
<li>cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</li>
</ul>
<p>ls   </p>
<ul>
<li>-l ：列出长数据串，包含文件的属性与权限数据等</li>
<li>-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</li>
<li>-d ：仅列出目录本身，而不是列出目录的文件数据</li>
<li>-h ：将文件容量以较易读的方式（GB，kB等）列出来</li>
<li>-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</li>
</ul>
<p>grep<br>命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等</p>
<ul>
<li>grep [-acinv] [–color=auto] ‘查找字符串’ filename</li>
<li>-a ：将binary文件以text文件的方式查找数据</li>
<li>-c ：计算找到‘查找字符串’的次数</li>
<li>-c ：计算找到‘查找字符串’的次数</li>
<li>-c ：计算找到‘查找字符串’的次数</li>
<li>-i ：忽略大小写的区别，即把大小写视为相同</li>
<li>-v ：反向选择，即显示出没有‘查找字符串’内容的那一行</li>
</ul>
<p>find 寻找<br>find [PATH] [option] [action]<br> 与时间有关的参数：</p>
<ul>
<li>-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；</li>
<li>-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；</li>
<li>-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；</li>
<li>-newer file : 列出比file还要新的文件名</li>
</ul>
<p>cp 复制</p>
<ul>
<li>-a ：将文件的特性一起复制</li>
<li>-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</li>
<li>-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</li>
<li>-r ：递归持续复制，用于目录的复制行为</li>
<li>-u ：目标文件与源文件有差异时才会复制<blockquote>
<p>cp from to 拷贝文件<br>cp -fr ./j2sdk1.4.2_04 /usr/java 拷贝目录</p>
</blockquote>
</li>
</ul>
<p>mv 剪切或重命名</p>
<ul>
<li>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</li>
<li>-i ：若目标文件已经存在，就会询问是否覆盖</li>
<li>-u ：若目标文件已经存在，且比目标文件新，才会更新</li>
</ul>
<p>rm 删除</p>
<ul>
<li>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</li>
<li>-i ：互动模式，在删除前会询问用户是否操作</li>
<li>-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</li>
</ul>
<p>ps 查看进程</p>
<ul>
<li>-A ：所有的进程均显示出来</li>
<li>-a ：不与terminal有关的所有进程</li>
<li>-u ：有效用户的相关进程</li>
<li>-x ：一般与a参数一起使用，可列出较完整的信息</li>
<li>-l ：较长，较详细地将PID的信息列出</li>
<li>ps aux # 查看系统所有的进程数据</li>
<li>ps ax # 查看不与terminal有关的所有进程</li>
<li>ps -lA # 查看系统所有的进程数据</li>
<li>ps axjf # 查看连同一部分进程树状态</li>
<li>ps -ef|grep java 查看进程</li>
<li>pstree |grep java 查看进程树<blockquote>
<p>ps aux|sort -n -r -k 5|head -5 按资源占用情况来排序，第一个 5 表示第几列，第二个 5 表示前几位</p>
</blockquote>
</li>
</ul>
<p>kill<br>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：kill -signal PID</p>
<ul>
<li>1：SIGHUP，启动被终止的进程</li>
<li>2：SIGINT，相当于输入ctrl+c，中断一个程序的进行</li>
<li>9：SIGKILL，强制中断一个进程的进行</li>
<li>15：SIGTERM，以正常的结束进程方式来终止进程</li>
<li>17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行</li>
</ul>
<ul>
<li>kill somePid 杀掉某进程</li>
<li>kill -9 $(ps -ef|grep udpserver | grep java|awk ‘{print $2}’ ) 删除 udpserver 进程<blockquote>
<p>如果存在进程杀掉<br>ps -ef | grep container-common-server-0.0.1.jar | grep -v grep | awk ‘{print $2}’ | xargs kill -9<br>后台启动进程输出&gt;/dev/null<br>setsid java -Xms256m -Xmx512m -jar container-common-server-0.0.1.jar –eureka.client.service-url.defaultZone=<a href="http://127.0.0.1:12111/eureka" target="_blank" rel="noopener">http://127.0.0.1:12111/eureka</a> –spring.cloud.config.profile=test &gt; /dev/null 2&gt;&amp;1 &amp;</p>
</blockquote>
</li>
</ul>
<p>killall</p>
<ul>
<li><p>-i ：交互式的意思，若需要删除时，会询问用户</p>
</li>
<li><p>-e ：表示后面接的command name要一致，但command name不能超过15个字符</p>
</li>
<li><p>-I ：命令名称忽略大小写</p>
<p>例如：</p>
</li>
<li><p>killall -SIGHUP syslogd # 重新启动syslogd</p>
</li>
</ul>
<p>file<br>用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的</p>
<ul>
<li>file filename<br>例如：<br>file ./test</li>
</ul>
<p>tar</p>
<ul>
<li>-c ：新建打包文件</li>
<li>-t ：查看打包文件的内容含有哪些文件名</li>
<li>-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</li>
<li>-j ：通过bzip2的支持进行压缩/解压缩</li>
<li>-z ：通过gzip的支持进行压缩/解压缩</li>
<li>-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</li>
<li>-f filename ：filename为要处理的文件</li>
<li>-C dir ：指定压缩/解压缩的目录dir<br>常用tar命令</li>
<li>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称</li>
<li>查询：tar -jtv -f filename.tar.bz2</li>
<li>解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</li>
<li>tar -xvzf  some.tar.gz 解压缩包</li>
<li>tar –cvzf some.tar.gz fileDir 打压缩包</li>
</ul>
<p>chgrp   改变文件所属所属用户组</p>
<ul>
<li>chgrp [-R] dirname/filename</li>
<li>-R ：进行递归的持续对所有文件和子目录更改</li>
</ul>
<p>例如：</p>
<ul>
<li>chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users</li>
</ul>
<p><strong>文件权限</strong></p>
<ul>
<li><p>chown 改变文件所有者   </p>
</li>
<li><p>chmod 改变文件权限</p>
</li>
<li><p>chmod [-R] xyz 文件或目录</p>
</li>
<li><p>-R：进行递归的持续更改，即连同子目录下的所有文件都会更改</p>
</li>
<li><p>chmod a+x somefile 所有用户都可以执行</p>
</li>
<li><p>chmod u+x somefile 当前用户可以执行</p>
</li>
</ul>
<ul>
<li>man rm （ rm –help ） 查看帮助</li>
</ul>
<p><strong>rpm</strong></p>
<ul>
<li><p>rpm -qa|grep php  查找RPM 文件</p>
</li>
<li><p>rpm -ivh some.rpm 安装软件</p>
</li>
<li><p>rpm -Uvh some.rpm 更新软件</p>
</li>
<li><p>rpm -qa |grep somesoftName 是否已安装某软件</p>
</li>
</ul>
<p><strong>系统层面</strong></p>
<ul>
<li><p>pwd 查看当前目录</p>
</li>
<li><p>ifconfig IP 地址配置，可以使用 setup 命令启动字符界面来配置</p>
</li>
<li><p>查看环境变量 env |grep PATH</p>
</li>
<li><p>输出变量名 echo</p>
</li>
<li><p>查看端口<br>netstat -npl<br>ss -tanl</p>
</li>
<li><p>开放端口<br>80端口  iptables -I INPUT -p TCP –dport 80 -j ACCEPT </p>
</li>
<li><p>mkdir 创建目录</p>
</li>
<li><p>rm -r 递归删除， -f 表示 force</p>
</li>
<li><p>which java 查看 java 进程对应的目录</p>
</li>
<li><p>where java 查看 java 命令目录</p>
</li>
<li><p>who 显示当前用户</p>
</li>
<li><p>zip -r filename.zip filesdir 某个文件夹打 zip 包</p>
</li>
<li><p>unzip somefile.zip 解压 zip 文档到当前目录</p>
</li>
<li><p>gunzip somefile.cpio.gz 解压 .gz</p>
</li>
<li><p>hostname -i 显示本机机器名，添加 i ，显示 etc/hosts 对应 ip 地址</p>
</li>
<li><p>reboot 立即重启服务器，相当于 shutdow –r now</p>
</li>
<li><p>关机， init 0</p>
</li>
<li><p>定时重启</p>
<ul>
<li><p>shutdonw -r 23:30</p>
</li>
<li><p>shutdown -r +15</p>
</li>
<li><p>shutdonw -r +30</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>setup 启动文字配置管理界面</p>
</li>
<li><p>vi /etc/sysconfig/network 修改机器名 , 然后要重启机器或者 service network restart</p>
</li>
<li><p>export LANG=zh_CN.GBK 设定系统语言，解决 consol 中文乱码</p>
</li>
<li><p>last 倒序查看已登陆用户历史</p>
</li>
<li><p>history 查看历史命令</p>
</li>
<li><p>date -s 10/09/2009  修改日期</p>
</li>
<li><p>date -s 13:24:00 修改时间，直接 date 显示时间</p>
</li>
<li><p>df -k  查看文件磁盘空间</p>
</li>
<li><p>df -v 查看文件空间</p>
</li>
<li><p>du 查看磁盘空间使用情况</p>
</li>
<li><p>free  查看内存使用情况</p>
</li>
<li><p>top  查看当前系统资源使用情况</p>
</li>
</ul>
<ul>
<li><p>service mysqld start 启动 mysql 服务，其他如此</p>
</li>
<li><p>service mysqld stop 停止 mysql 服务</p>
</li>
<li><p>serice mysqld status 显示 mysql 服务状态</p>
</li>
<li><p>service –status-al 查看已有服务</p>
</li>
<li><p>服务 systemctl</p>
</li>
</ul>
<p><strong>docker 部分命令</strong></p>
<ul>
<li><p>docker run –name ldj-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d docker.io/mysql</p>
</li>
<li><p>docker run -p 8000:80 –name myNginx -d docker.io/nginx </p>
</li>
<li><p>docker run -it  –name dockerGit -d docker/git:git</p>
</li>
<li><p>docker run -it -d –name docker-web -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock docker.io/uifd/ui-for-docker</p>
</li>
<li><p>docker exec -it ldj-mysql /bin/bash</p>
</li>
</ul>
<p><strong>文件</strong></p>
<p>find 查找文件</p>
<ul>
<li><p>grep someText * 在当前目录所有文本中查找</p>
</li>
<li><p>cat<br>用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据</p>
<ul>
<li>cat text | less # 查看text文件中的内容 注：这条命令也可以使用less text来代替</li>
</ul>
</li>
<li><p>tail -10 someFile  查看文件后 10 行内容</p>
</li>
<li><p>head -10 someFile   查看文件前 10 行内容</p>
</li>
<li><p>tail -f someFile   实时查看文件内容，用于调试</p>
</li>
</ul>
<ul>
<li>Linux 向文件末尾追加命令<br>//echo后边用单引号包围要添加的内容<br>echo ‘add content’&gt;&gt;/home/data/test.sh<br>注意：&gt;&gt; 是追加<br>echo ‘add content’&gt;/home/data/test.sh<br>注意：&gt; 是删除原有内容，添加</li>
</ul>
<p>文件替换</p>
<ul>
<li><p>文件内全部替换：</p>
<ul>
<li>:%s#abc#123#g (如文件内有#，可用/替换,:%s/abc/123/g)  </li>
<li>-注：把abc替换成123<br>(或者: %s/str1/str2/g 用str2替换文件中所有的str1）</li>
</ul>
</li>
<li><p>文件内局部替换：</p>
<ul>
<li>:20,30s#abc#123(如文件内有#，可用/替换,:%s/abc/123/g)  </li>
<li>-注：把20行到30行内abc替换成123</li>
</ul>
</li>
</ul>
<p><strong>scp</strong></p>
<ul>
<li><p>远程到本地</p>
<ul>
<li>scp -r <a href="mailto:root@192.168.120.204">root@192.168.120.204</a>:/opt/soft/mongodb /opt/soft/</li>
</ul>
</li>
<li><p>本地到远程</p>
<ul>
<li>scp -r /opt/veolia/*.jar <a href="mailto:test@112.35.123.200">test@112.35.123.200</a>:/home/test</li>
</ul>
</li>
<li><p>从linux系统复制文件到windows系统： </p>
<ul>
<li>scp /oracle/a.txt <a href="mailto:administrator@192.168.3.181">administrator@192.168.3.181</a>:/d:/</li>
</ul>
</li>
<li><p>在linux环境下，将windows下的文件复制到linux系统中： </p>
<ul>
<li>scp <a href="mailto:administrator@192.168.3.181">administrator@192.168.3.181</a>:/d:/test/abc.txt /oracle<br>其中的administrator是windows的用户名，比如我的windows用户名是fts。192.168.3.181是你windows的ip/oracle是你要存放的Windows路径</li>
</ul>
</li>
</ul>
<p>需要注意的是：因为windows系统本身不支持ssh协议，所以，要想上面的命令成功执行，必须在windows客户端安装ssh for windows的客户端软件，<br>比如winsshd，使windows系统支持ssh协议才行。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel导入优化</title>
    <url>/2020/02/25/excel/</url>
    <content><![CDATA[<h1 id="导入优化"><a href="#导入优化" class="headerlink" title="导入优化"></a>导入优化</h1><p>工作中遇到一个问题，在进行导入操作时，将大量数据通过excel导入至数据库中时，性能奇差，导入200条数据已是极限，已经远远达不到预期效果，经笔者解决后效率得到大幅提升，由200-300条数据死机到10s内导入2000条以上，基本达到业务要求，今日便与各位分享一下各中心得与问题。</p>
<a id="more"></a>
<p>  基本业务逻辑：</p>
<pre><code>此功能为导入学生信息，导入的学生信息可以为新增数据，也可以为已有数据（根据身份证判断），导入的学生信息包括学生个人信息，学生户籍地、实际居住地信息，学生专业信息，导入时同时还有对未注册学生进行注册账户操作，在导入时记录log</code></pre><p>原有操作逻辑：</p>
<p>从excel读取每一条要导入的dataList ，遍历dataList,在每一条数据中进行如下操作</p>
<p>一、 拿到id判断是插入还是更新，如为更新操作，则省略部分字段校验的字段与更新，插入操作则对每个字段按规则进行校验并创建学生账号。</p>
<p>二、根据数据去数据库中查询户籍地信息是否正确，此处学生的户籍地信息分为省，市，区，具体地址四个字段，主要依据行政区划表查询省市区是否对应，实际居住地逻辑于此相同。</p>
<p>三、学生专业信息包含文化层次、报名方向，报名层次，专业四个字段，而学生信息中包含第一志愿与第二志愿，志愿信息由报名方向，报名层次，专业组成，每一条志愿都须去招生计划表中查询招生计划是否存在，</p>
<p>四、查询推荐教师是否存在（查询user表）</p>
<p>五、向log表中记录log</p>
<p>六、保存（更新）记录</p>
<p>这个项目为老项目，从前开发者为了省力直接调用已有api，哪怕十分冗余，大致看去，很多数据库相关操作可以放到循环外执行，只是为了方便把数据库操作放到循环里，所有笔者一开始尽量把有关数据库操作放到了循环外。但即便这样实现效果依旧不理想。经过一段时间的考虑笔者将代码优化至如下流程。</p>
<p>1、创建datalist，优化初始空间，由于理论上单次导入学生不会超过10000条，直接将list初始化容量控制在这个范围，</p>
<p>从数据库中查出学生集合，按此容量创建并填充idmap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Map&lt;String, ZsStudent&gt; identityCardMap </span><br><span class="line">&#x3D; new HashMap&lt;String, ZsStudent&gt;((int) (dbStuList.size() &#x2F; 0.75) + 1);</span><br></pre></td></tr></table></figure>
<p>避免多次rehash降低效率，id为key, student 为value，将excel数据放入list———datalist</p>
<p>2、查询所有有关招生计划，转为list，值为文化层次、报名方向，报名层次，专业拼接——招生list</p>
<p>  在用户登录时查询省市区值，将其放入redis—-地区缓存（分为3个map）（先删后存）</p>
<p>推荐教师读取其他功能配置，放入缓存—–教师缓存</p>
<p>2、创建insertList，updateList，每个list3个，每个list的size控制在3000，遍历dataMap，如为插入数据则将其放入insertList，update同理</p>
<p>遍历map时按与招生计划一样的规则填充list—–志愿list，遍历datalist时通过地区缓存判断学生地区是否正确，通过教师缓存判断教师是否为所配置推荐教师，如异常则break跳出循环，返回提示,datalist遍历完毕。</p>
<p>3、判断招生list是否存在志愿list？“”：返回提示；</p>
<p>4、log不在单独记录，只记录共读取数据数。</p>
<p>5、创建中间表，此表有所有所需要的字段，将updateList放入此表，将此表更新至各表，删除此表，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &#x2F;*创建临时表*&#x2F;</span><br><span class="line">   void creatStudentAndUserTemp();</span><br><span class="line"></span><br><span class="line">   &#x2F;*需要更新的学生数据插入临时表*&#x2F;</span><br><span class="line">   void insertStudentAndUser(List&lt;ZsStudent&gt; updateStudentLists);</span><br><span class="line"></span><br><span class="line">   &#x2F;*根据临时表更新xg_student表*&#x2F;</span><br><span class="line">   void updateStudent();</span><br><span class="line"></span><br><span class="line">   &#x2F;*根据临时表更新sys_user表*&#x2F;</span><br><span class="line">   void updateUser();</span><br><span class="line"></span><br><span class="line">   &#x2F;*删除临时表*&#x2F;</span><br><span class="line">   void dropStudentAndUserTemp();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   void insertStudent(List&lt;ZsStudent&gt; insertStudentLists);</span><br><span class="line"></span><br><span class="line">   &#x2F;*根据临时表更新sys_user表*&#x2F;</span><br><span class="line">   void insertUser(List&lt;ZsStudent&gt; insertStudentLists);</span><br><span class="line"></span><br><span class="line">   &#x2F;*学生导入时-批量插入用户角色关联数据*&#x2F;</span><br><span class="line">   void insertImpportUserRole(@Param(&quot;list&quot;) List&lt;ZsStudent&gt; </span><br><span class="line">insertStudentLists,@Param(&quot;roleId&quot;) String roleId);</span><br><span class="line"></span><br><span class="line">   &#x2F;*根据临时表更新volunteer表*&#x2F;</span><br><span class="line">   void updateVolunteer();</span><br><span class="line">   &#x2F;*插入volunteer表*&#x2F;</span><br><span class="line">   void insertVolunteer(List&lt;ZsStudent&gt; insertStudentLists);</span><br></pre></td></tr></table></figure>
<p>insertList走branchInsert方法插入数据库。</p>
<p>上述即为优化后的基本逻辑，主要将需多次查询数据库操作放入缓存，尽可能减少数据库操作，减少循环中业务操作，</p>
<p>目前方案减少了数据库操作是因为将数据库操作分散，放入缓存，在导入大数据量数据时会占用大量内存（hashmap），但这是目前比较可以接受的方案，经过优化导入功能整体的性能也得到了提高。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>业务</tag>
      </tags>
  </entry>
</search>
