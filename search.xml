<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>stream流简单应用</title>
    <url>/2020/03/01/stream/</url>
    <content><![CDATA[<p>jdk13已经发布了，许多小伙伴连jdk8都没摸透，笔者在这里简单向各位介绍下jdk8中的一些api，这些也是笔者在实际工作中用到的，如有疏漏，请多海涵。</p>
<p>如果各位同学想要学习可以先知道基本用法，留个印象，在遇到时就百度，多遇到几次自然会记住，死记硬背只能徒增痛苦，</p>
<p>java中主要新加了stream流式编程与lambda表达式，lambda主要简化了一些写法，stream则提供了一些方法是编程人员能更方便的处理数据。话不多说我们主要来看具体的应用。</p>
<a id="more"></a>
<h3 id="场景一：把list转为map，对象中的id作为key，对象作为value"><a href="#场景一：把list转为map，对象中的id作为key，对象作为value" class="headerlink" title="场景一：把list转为map，对象中的id作为key，对象作为value"></a>场景一：把list转为map，对象中的id作为key，对象作为value</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map &lt;String,Object&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">for(Object o:list)&#123;</span><br><span class="line">    map.put(o.getid(),o);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是在java8前，大家肯定都会像上面这样写，但这样写不够优雅，在java8 后我们可以更方便的写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; list.stream().collect(Collectors.toMap(Object::getId, Obejct));</span><br></pre></td></tr></table></figure>
<p>这样一行就可以搞定，可读性高。</p>
<h3 id="场景二：计算list中属性和"><a href="#场景二：计算list中属性和" class="headerlink" title="场景二：计算list中属性和"></a>场景二：计算list中属性和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">heji.setFee(feeList.stream().map(i-&gt;i.getFee()).reduce((float)0, (a, b) -&gt; a + b));</span><br></pre></td></tr></table></figure>
<h3 id="场景三：获取学生专业的部门信息"><a href="#场景三：获取学生专业的部门信息" class="headerlink" title="场景三：获取学生专业的部门信息"></a>场景三：获取学生专业的部门信息</h3><p>使用option可以很方便的判断null值，并设置默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(student.getMajor())</span><br><span class="line">    .map(i-&gt;i.getDepartment())</span><br><span class="line">    .map(i-&gt;i.getName())</span><br><span class="line">    .orElse(&quot;&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="场景四：判断list中join属性是否为空，不为空则将其设置至实体中"><a href="#场景四：判断list中join属性是否为空，不为空则将其设置至实体中" class="headerlink" title="场景四：判断list中join属性是否为空，不为空则将其设置至实体中"></a>场景四：判断list中join属性是否为空，不为空则将其设置至实体中</h3><p>==Optional判断list时无法判断size为0的情况，所以要加上filter==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(enrollmentList)</span><br><span class="line">        .filter(i -&gt; i.size() !&#x3D; 0)</span><br><span class="line">        .map(i -&gt; i.get(0))</span><br><span class="line">        .map(i -&gt; i.getJoin())</span><br><span class="line">        .ifPresent(</span><br><span class="line">                join -&gt; &#123;</span><br><span class="line">                    xgStudent.setJoinName(join.getJoinName());</span><br><span class="line">                    xgStudent.setJoinForm(join.getId());</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<h3 id="场景五-获取teacherList的教师姓名列表"><a href="#场景五-获取teacherList的教师姓名列表" class="headerlink" title="场景五:获取teacherList的教师姓名列表"></a>场景五:获取teacherList的教师姓名列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xgStudentService.getTeacherList(teacherids).stream()</span><br><span class="line">.map(t -&gt; t.getName())</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="场景六：获取list的id并将其拼接"><a href="#场景六：获取list的id并将其拼接" class="headerlink" title="场景六：获取list的id并将其拼接"></a>场景六：获取list的id并将其拼接</h3><p>==从左至右为分隔符，前缀，后缀==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">professionalList.stream()</span><br><span class="line">        .map(i -&gt; i.getId())</span><br><span class="line">        .collect(Collectors.joining(&quot;&#39;,&#39;&quot;, &quot;&#39;&quot;, &quot;&#39;&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="场景七：将departList按id去重并返回list"><a href="#场景七：将departList按id去重并返回list" class="headerlink" title="场景七：将departList按id去重并返回list"></a>场景七：将departList按id去重并返回list</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">depart.stream().filter(i-&gt;StringUtils.isNotBlank(i.getName())).collect(</span><br><span class="line">        collectingAndThen(</span><br><span class="line">                toCollection(() -&gt; new TreeSet&lt;&gt;(comparing(n -&gt; n.getId()))), ArrayList::new));</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令</title>
    <url>/2020/02/27/linux/</url>
    <content><![CDATA[<p><strong>常用Linux命令</strong></p>
<p>本文记录了一些常用的linux命令</p>
<a id="more"></a>
<p>cd</p>
<ul>
<li>cd /root/Docements # 切换到目录/root/Docements</li>
<li>cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录</li>
<li>cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</li>
</ul>
<p>ls   </p>
<ul>
<li>-l ：列出长数据串，包含文件的属性与权限数据等</li>
<li>-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</li>
<li>-d ：仅列出目录本身，而不是列出目录的文件数据</li>
<li>-h ：将文件容量以较易读的方式（GB，kB等）列出来</li>
<li>-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</li>
</ul>
<p>grep<br>命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等</p>
<ul>
<li>grep [-acinv] [–color=auto] ‘查找字符串’ filename</li>
<li>-a ：将binary文件以text文件的方式查找数据</li>
<li>-c ：计算找到‘查找字符串’的次数</li>
<li>-c ：计算找到‘查找字符串’的次数</li>
<li>-c ：计算找到‘查找字符串’的次数</li>
<li>-i ：忽略大小写的区别，即把大小写视为相同</li>
<li>-v ：反向选择，即显示出没有‘查找字符串’内容的那一行</li>
</ul>
<p>find 寻找<br>find [PATH] [option] [action]<br> 与时间有关的参数：</p>
<ul>
<li>-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；</li>
<li>-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；</li>
<li>-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；</li>
<li>-newer file : 列出比file还要新的文件名</li>
</ul>
<p>cp 复制</p>
<ul>
<li>-a ：将文件的特性一起复制</li>
<li>-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</li>
<li>-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</li>
<li>-r ：递归持续复制，用于目录的复制行为</li>
<li>-u ：目标文件与源文件有差异时才会复制<blockquote>
<p>cp from to 拷贝文件<br>cp -fr ./j2sdk1.4.2_04 /usr/java 拷贝目录</p>
</blockquote>
</li>
</ul>
<p>mv 剪切或重命名</p>
<ul>
<li>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</li>
<li>-i ：若目标文件已经存在，就会询问是否覆盖</li>
<li>-u ：若目标文件已经存在，且比目标文件新，才会更新</li>
</ul>
<p>rm 删除</p>
<ul>
<li>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</li>
<li>-i ：互动模式，在删除前会询问用户是否操作</li>
<li>-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</li>
</ul>
<p>ps 查看进程</p>
<ul>
<li>-A ：所有的进程均显示出来</li>
<li>-a ：不与terminal有关的所有进程</li>
<li>-u ：有效用户的相关进程</li>
<li>-x ：一般与a参数一起使用，可列出较完整的信息</li>
<li>-l ：较长，较详细地将PID的信息列出</li>
<li>ps aux # 查看系统所有的进程数据</li>
<li>ps ax # 查看不与terminal有关的所有进程</li>
<li>ps -lA # 查看系统所有的进程数据</li>
<li>ps axjf # 查看连同一部分进程树状态</li>
<li>ps -ef|grep java 查看进程</li>
<li>pstree |grep java 查看进程树<blockquote>
<p>ps aux|sort -n -r -k 5|head -5 按资源占用情况来排序，第一个 5 表示第几列，第二个 5 表示前几位</p>
</blockquote>
</li>
</ul>
<p>kill<br>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：kill -signal PID</p>
<ul>
<li>1：SIGHUP，启动被终止的进程</li>
<li>2：SIGINT，相当于输入ctrl+c，中断一个程序的进行</li>
<li>9：SIGKILL，强制中断一个进程的进行</li>
<li>15：SIGTERM，以正常的结束进程方式来终止进程</li>
<li>17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行</li>
</ul>
<ul>
<li>kill somePid 杀掉某进程</li>
<li>kill -9 $(ps -ef|grep udpserver | grep java|awk ‘{print $2}’ ) 删除 udpserver 进程<blockquote>
<p>如果存在进程杀掉<br>ps -ef | grep container-common-server-0.0.1.jar | grep -v grep | awk ‘{print $2}’ | xargs kill -9<br>后台启动进程输出&gt;/dev/null<br>setsid java -Xms256m -Xmx512m -jar container-common-server-0.0.1.jar –eureka.client.service-url.defaultZone=<a href="http://127.0.0.1:12111/eureka" target="_blank" rel="noopener">http://127.0.0.1:12111/eureka</a> –spring.cloud.config.profile=test &gt; /dev/null 2&gt;&amp;1 &amp;</p>
</blockquote>
</li>
</ul>
<p>killall</p>
<ul>
<li><p>-i ：交互式的意思，若需要删除时，会询问用户</p>
</li>
<li><p>-e ：表示后面接的command name要一致，但command name不能超过15个字符</p>
</li>
<li><p>-I ：命令名称忽略大小写</p>
<p>例如：</p>
</li>
<li><p>killall -SIGHUP syslogd # 重新启动syslogd</p>
</li>
</ul>
<p>file<br>用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的</p>
<ul>
<li>file filename<br>例如：<br>file ./test</li>
</ul>
<p>tar</p>
<ul>
<li>-c ：新建打包文件</li>
<li>-t ：查看打包文件的内容含有哪些文件名</li>
<li>-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</li>
<li>-j ：通过bzip2的支持进行压缩/解压缩</li>
<li>-z ：通过gzip的支持进行压缩/解压缩</li>
<li>-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</li>
<li>-f filename ：filename为要处理的文件</li>
<li>-C dir ：指定压缩/解压缩的目录dir<br>常用tar命令</li>
<li>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称</li>
<li>查询：tar -jtv -f filename.tar.bz2</li>
<li>解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</li>
<li>tar -xvzf  some.tar.gz 解压缩包</li>
<li>tar –cvzf some.tar.gz fileDir 打压缩包</li>
</ul>
<p>chgrp   改变文件所属所属用户组</p>
<ul>
<li>chgrp [-R] dirname/filename</li>
<li>-R ：进行递归的持续对所有文件和子目录更改</li>
</ul>
<p>例如：</p>
<ul>
<li>chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users</li>
</ul>
<p><strong>文件权限</strong></p>
<ul>
<li><p>chown 改变文件所有者   </p>
</li>
<li><p>chmod 改变文件权限</p>
</li>
<li><p>chmod [-R] xyz 文件或目录</p>
</li>
<li><p>-R：进行递归的持续更改，即连同子目录下的所有文件都会更改</p>
</li>
<li><p>chmod a+x somefile 所有用户都可以执行</p>
</li>
<li><p>chmod u+x somefile 当前用户可以执行</p>
</li>
</ul>
<ul>
<li>man rm （ rm –help ） 查看帮助</li>
</ul>
<p><strong>rpm</strong></p>
<ul>
<li><p>rpm -qa|grep php  查找RPM 文件</p>
</li>
<li><p>rpm -ivh some.rpm 安装软件</p>
</li>
<li><p>rpm -Uvh some.rpm 更新软件</p>
</li>
<li><p>rpm -qa |grep somesoftName 是否已安装某软件</p>
</li>
</ul>
<p><strong>系统层面</strong></p>
<ul>
<li><p>pwd 查看当前目录</p>
</li>
<li><p>ifconfig IP 地址配置，可以使用 setup 命令启动字符界面来配置</p>
</li>
<li><p>查看环境变量 env |grep PATH</p>
</li>
<li><p>输出变量名 echo</p>
</li>
<li><p>查看端口<br>netstat -npl<br>ss -tanl</p>
</li>
<li><p>开放端口<br>80端口  iptables -I INPUT -p TCP –dport 80 -j ACCEPT </p>
</li>
<li><p>mkdir 创建目录</p>
</li>
<li><p>rm -r 递归删除， -f 表示 force</p>
</li>
<li><p>which java 查看 java 进程对应的目录</p>
</li>
<li><p>where java 查看 java 命令目录</p>
</li>
<li><p>who 显示当前用户</p>
</li>
<li><p>zip -r filename.zip filesdir 某个文件夹打 zip 包</p>
</li>
<li><p>unzip somefile.zip 解压 zip 文档到当前目录</p>
</li>
<li><p>gunzip somefile.cpio.gz 解压 .gz</p>
</li>
<li><p>hostname -i 显示本机机器名，添加 i ，显示 etc/hosts 对应 ip 地址</p>
</li>
<li><p>reboot 立即重启服务器，相当于 shutdow –r now</p>
</li>
<li><p>关机， init 0</p>
</li>
<li><p>定时重启</p>
<ul>
<li><p>shutdonw -r 23:30</p>
</li>
<li><p>shutdown -r +15</p>
</li>
<li><p>shutdonw -r +30</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>setup 启动文字配置管理界面</p>
</li>
<li><p>vi /etc/sysconfig/network 修改机器名 , 然后要重启机器或者 service network restart</p>
</li>
<li><p>export LANG=zh_CN.GBK 设定系统语言，解决 consol 中文乱码</p>
</li>
<li><p>last 倒序查看已登陆用户历史</p>
</li>
<li><p>history 查看历史命令</p>
</li>
<li><p>date -s 10/09/2009  修改日期</p>
</li>
<li><p>date -s 13:24:00 修改时间，直接 date 显示时间</p>
</li>
<li><p>df -k  查看文件磁盘空间</p>
</li>
<li><p>df -v 查看文件空间</p>
</li>
<li><p>du 查看磁盘空间使用情况</p>
</li>
<li><p>free  查看内存使用情况</p>
</li>
<li><p>top  查看当前系统资源使用情况</p>
</li>
</ul>
<ul>
<li><p>service mysqld start 启动 mysql 服务，其他如此</p>
</li>
<li><p>service mysqld stop 停止 mysql 服务</p>
</li>
<li><p>serice mysqld status 显示 mysql 服务状态</p>
</li>
<li><p>service –status-al 查看已有服务</p>
</li>
<li><p>服务 systemctl</p>
</li>
</ul>
<p><strong>docker 部分命令</strong></p>
<ul>
<li><p>docker run –name ldj-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d docker.io/mysql</p>
</li>
<li><p>docker run -p 8000:80 –name myNginx -d docker.io/nginx </p>
</li>
<li><p>docker run -it  –name dockerGit -d docker/git:git</p>
</li>
<li><p>docker run -it -d –name docker-web -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock docker.io/uifd/ui-for-docker</p>
</li>
<li><p>docker exec -it ldj-mysql /bin/bash</p>
</li>
</ul>
<p><strong>文件</strong></p>
<p>find 查找文件</p>
<ul>
<li><p>grep someText * 在当前目录所有文本中查找</p>
</li>
<li><p>cat<br>用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据</p>
<ul>
<li>cat text | less # 查看text文件中的内容 注：这条命令也可以使用less text来代替</li>
</ul>
</li>
<li><p>tail -10 someFile  查看文件后 10 行内容</p>
</li>
<li><p>head -10 someFile   查看文件前 10 行内容</p>
</li>
<li><p>tail -f someFile   实时查看文件内容，用于调试</p>
</li>
</ul>
<ul>
<li>Linux 向文件末尾追加命令<br>//echo后边用单引号包围要添加的内容<br>echo ‘add content’&gt;&gt;/home/data/test.sh<br>注意：&gt;&gt; 是追加<br>echo ‘add content’&gt;/home/data/test.sh<br>注意：&gt; 是删除原有内容，添加</li>
</ul>
<p>文件替换</p>
<ul>
<li><p>文件内全部替换：</p>
<ul>
<li>:%s#abc#123#g (如文件内有#，可用/替换,:%s/abc/123/g)  </li>
<li>-注：把abc替换成123<br>(或者: %s/str1/str2/g 用str2替换文件中所有的str1）</li>
</ul>
</li>
<li><p>文件内局部替换：</p>
<ul>
<li>:20,30s#abc#123(如文件内有#，可用/替换,:%s/abc/123/g)  </li>
<li>-注：把20行到30行内abc替换成123</li>
</ul>
</li>
</ul>
<p><strong>scp</strong></p>
<ul>
<li><p>远程到本地</p>
<ul>
<li>scp -r <a href="mailto:root@192.168.120.204">root@192.168.120.204</a>:/opt/soft/mongodb /opt/soft/</li>
</ul>
</li>
<li><p>本地到远程</p>
<ul>
<li>scp -r /opt/veolia/*.jar <a href="mailto:test@112.35.123.200">test@112.35.123.200</a>:/home/test</li>
</ul>
</li>
<li><p>从linux系统复制文件到windows系统： </p>
<ul>
<li>scp /oracle/a.txt <a href="mailto:administrator@192.168.3.181">administrator@192.168.3.181</a>:/d:/</li>
</ul>
</li>
<li><p>在linux环境下，将windows下的文件复制到linux系统中： </p>
<ul>
<li>scp <a href="mailto:administrator@192.168.3.181">administrator@192.168.3.181</a>:/d:/test/abc.txt /oracle<br>其中的administrator是windows的用户名，比如我的windows用户名是fts。192.168.3.181是你windows的ip/oracle是你要存放的Windows路径</li>
</ul>
</li>
</ul>
<p>需要注意的是：因为windows系统本身不支持ssh协议，所以，要想上面的命令成功执行，必须在windows客户端安装ssh for windows的客户端软件，<br>比如winsshd，使windows系统支持ssh协议才行。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel导入优化</title>
    <url>/2020/02/25/excel/</url>
    <content><![CDATA[<h1 id="导入优化"><a href="#导入优化" class="headerlink" title="导入优化"></a>导入优化</h1><p>工作中遇到一个问题，在进行导入操作时，将大量数据通过excel导入至数据库中时，性能奇差，导入200条数据已是极限，已经远远达不到预期效果，经笔者解决后效率得到大幅提升，由200-300条数据死机到10s内导入2000条以上，基本达到业务要求，今日便与各位分享一下各中心得与问题。</p>
<a id="more"></a>
<p>  基本业务逻辑：</p>
<pre><code>此功能为导入学生信息，导入的学生信息可以为新增数据，也可以为已有数据（根据身份证判断），导入的学生信息包括学生个人信息，学生户籍地、实际居住地信息，学生专业信息，导入时同时还有对未注册学生进行注册账户操作，在导入时记录log</code></pre><p>原有操作逻辑：</p>
<p>从excel读取每一条要导入的dataList ，遍历dataList,在每一条数据中进行如下操作</p>
<p>一、 拿到id判断是插入还是更新，如为更新操作，则省略部分字段校验的字段与更新，插入操作则对每个字段按规则进行校验并创建学生账号。</p>
<p>二、根据数据去数据库中查询户籍地信息是否正确，此处学生的户籍地信息分为省，市，区，具体地址四个字段，主要依据行政区划表查询省市区是否对应，实际居住地逻辑于此相同。</p>
<p>三、学生专业信息包含文化层次、报名方向，报名层次，专业四个字段，而学生信息中包含第一志愿与第二志愿，志愿信息由报名方向，报名层次，专业组成，每一条志愿都须去招生计划表中查询招生计划是否存在，</p>
<p>四、查询推荐教师是否存在（查询user表）</p>
<p>五、向log表中记录log</p>
<p>六、保存（更新）记录</p>
<p>这个项目为老项目，从前开发者为了省力直接调用已有api，哪怕十分冗余，大致看去，很多数据库相关操作可以放到循环外执行，只是为了方便把数据库操作放到循环里，所有笔者一开始尽量把有关数据库操作放到了循环外。但即便这样实现效果依旧不理想。经过一段时间的考虑笔者将代码优化至如下流程。</p>
<p>1、创建datalist，优化初始空间，由于理论上单次导入学生不会超过10000条，直接将list初始化容量控制在这个范围，</p>
<p>从数据库中查出学生集合，按此容量创建并填充idmap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Map&lt;String, ZsStudent&gt; identityCardMap </span><br><span class="line">&#x3D; new HashMap&lt;String, ZsStudent&gt;((int) (dbStuList.size() &#x2F; 0.75) + 1);</span><br></pre></td></tr></table></figure>
<p>避免多次rehash降低效率，id为key, student 为value，将excel数据放入list———datalist</p>
<p>2、查询所有有关招生计划，转为list，值为文化层次、报名方向，报名层次，专业拼接——招生list</p>
<p>  在用户登录时查询省市区值，将其放入redis—-地区缓存（分为3个map）（先删后存）</p>
<p>推荐教师读取其他功能配置，放入缓存—–教师缓存</p>
<p>2、创建insertList，updateList，每个list3个，每个list的size控制在3000，遍历dataMap，如为插入数据则将其放入insertList，update同理</p>
<p>遍历map时按与招生计划一样的规则填充list—–志愿list，遍历datalist时通过地区缓存判断学生地区是否正确，通过教师缓存判断教师是否为所配置推荐教师，如异常则break跳出循环，返回提示,datalist遍历完毕。</p>
<p>3、判断招生list是否存在志愿list？“”：返回提示；</p>
<p>4、log不在单独记录，只记录共读取数据数。</p>
<p>5、创建中间表，此表有所有所需要的字段，将updateList放入此表，将此表更新至各表，删除此表，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &#x2F;*创建临时表*&#x2F;</span><br><span class="line">   void creatStudentAndUserTemp();</span><br><span class="line"></span><br><span class="line">   &#x2F;*需要更新的学生数据插入临时表*&#x2F;</span><br><span class="line">   void insertStudentAndUser(List&lt;ZsStudent&gt; updateStudentLists);</span><br><span class="line"></span><br><span class="line">   &#x2F;*根据临时表更新xg_student表*&#x2F;</span><br><span class="line">   void updateStudent();</span><br><span class="line"></span><br><span class="line">   &#x2F;*根据临时表更新sys_user表*&#x2F;</span><br><span class="line">   void updateUser();</span><br><span class="line"></span><br><span class="line">   &#x2F;*删除临时表*&#x2F;</span><br><span class="line">   void dropStudentAndUserTemp();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   void insertStudent(List&lt;ZsStudent&gt; insertStudentLists);</span><br><span class="line"></span><br><span class="line">   &#x2F;*根据临时表更新sys_user表*&#x2F;</span><br><span class="line">   void insertUser(List&lt;ZsStudent&gt; insertStudentLists);</span><br><span class="line"></span><br><span class="line">   &#x2F;*学生导入时-批量插入用户角色关联数据*&#x2F;</span><br><span class="line">   void insertImpportUserRole(@Param(&quot;list&quot;) List&lt;ZsStudent&gt; </span><br><span class="line">insertStudentLists,@Param(&quot;roleId&quot;) String roleId);</span><br><span class="line"></span><br><span class="line">   &#x2F;*根据临时表更新volunteer表*&#x2F;</span><br><span class="line">   void updateVolunteer();</span><br><span class="line">   &#x2F;*插入volunteer表*&#x2F;</span><br><span class="line">   void insertVolunteer(List&lt;ZsStudent&gt; insertStudentLists);</span><br></pre></td></tr></table></figure>
<p>insertList走branchInsert方法插入数据库。</p>
<p>上述即为优化后的基本逻辑，主要将需多次查询数据库操作放入缓存，尽可能减少数据库操作，减少循环中业务操作，</p>
<p>目前方案减少了数据库操作是因为将数据库操作分散，放入缓存，在导入大数据量数据时会占用大量内存（hashmap），但这是目前比较可以接受的方案，经过优化导入功能整体的性能也得到了提高。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>业务</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引概述</title>
    <url>/2020/02/25/suoyin/</url>
    <content><![CDATA[<p><strong>概述</strong><br>索引是数据库很重要的一块知识点，在实际工作中会经常涉及，笔者将在本文中向各位介绍一下</p>
<a id="more"></a>
<p><em>索引的目的在于提高查询效率</em></p>
<p><strong>缺点</strong></p>
<ul>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT,UPDATE和DELETE。因为更新表时，mysql不仅要保存数据，还要保存一下索引文件</li>
<li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在要给大表上建了多种组合索引，索引文件会膨胀很宽   </li>
<li>索引只是提高效率的一个方式，如果mysql有大数据量的表，就要花时间研究建立最优的索引，或优化查询语句。</li>
</ul>
<p>代码  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）</span><br><span class="line">&#x2F;&#x2F;普通索引</span><br><span class="line">alter table table_name add index index_name (column_list) ;</span><br><span class="line">&#x2F;&#x2F;唯一索引</span><br><span class="line">alter table table_name add unique (column_list) ;</span><br><span class="line">&#x2F;&#x2F;主键索引</span><br><span class="line">alter table table_name add primary key (column_list) ;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name(username(length)); </span><br><span class="line">&#x2F;&#x2F;create只能添加这两种索引;</span><br><span class="line">CREATE INDEX index_name ON table_name (column_list)</span><br><span class="line">CREATE UNIQUE INDEX index_name ON table_name (column_list)</span><br></pre></td></tr></table></figure>
<h2 id="使用技巧及注意事项"><a href="#使用技巧及注意事项" class="headerlink" title="使用技巧及注意事项"></a>使用技巧及注意事项</h2><ol>
<li><p>索引不会包含有NULL的列   </p>
<pre><code>只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。   </code></pre></li>
<li><p>使用短索引  </p>
<pre><code>对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</code></pre></li>
<li><p>索引列排序  </p>
<pre><code>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。</code></pre></li>
<li><p>like语句操作<br>一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。</p>
</li>
<li><p>不要在列上进行运算</p>
</li>
<li><p>不使用NOT IN 、&lt;&gt;、！=操作，但&lt;,&lt;=，=，&gt;,&gt;=,BETWEEN,IN是可以用到索引的</p>
</li>
<li><p>索引要建立在经常进行select操作的字段上。<br>  这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
</li>
<li><p>索引要建立在值比较唯一的字段上。</p>
</li>
<li><p>对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。</p>
</li>
<li><p>在where和join中出现的列需要建立索引。</p>
</li>
<li><p>where的查询条件里有不等号(where column != …),mysql将无法使用索引。</p>
</li>
<li><p>如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引。</p>
</li>
<li><p>在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。</p>
</li>
</ol>
<h2 id="索引的结构及种类"><a href="#索引的结构及种类" class="headerlink" title="索引的结构及种类"></a>索引的结构及种类</h2><p>数据库索引从物理结构上分为聚集索引和非聚集索引</p>
<ol>
<li>聚集索引即索引项在物理结构上是连续的，依据索引规则紧密排序，mysql的主键索引就是聚集索引，优点是查找快，缺点是增删耗费的时间慢，因为如果以乱序插入就会不断破坏原有数据的结构，尤其像mysql索引以b+树结构存储，如以uuid作为主键将耗费大量时间</li>
<li>非聚集索引即为索引项在物理结构上不连续  </li>
</ol>
<p><strong>数据库索引从逻辑结构上分为几种，主键索引，唯一索引，联合索引，位图索引</strong></p>
<ol>
<li>主键索引及表在建立是以主键作为索引项建立的索引，默认为聚集索引</li>
<li>唯一索引，能确定某个数据列将只包含彼此各不相同的值，这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</li>
<li>联合索引可以覆盖多个数据列不过遵循最左前缀原则</li>
<li>位图索引，用于重复值较高的字段例如性别等，1是0非查询时利用&amp;运算快速求解  </li>
</ol>
<p><strong>最左前缀</strong></p>
<ol>
<li><strong>索引左前缀性的第一层意思：必须用到索引的第一个字段</strong>。select * from AAA where b=:xxx and c=sysdate;则不会用到索引，因为必须有a出现在where 语句中才会使用到该索引。</li>
<li><strong>索引前缀性的第二层意思：对于索引的第一个字段，用like时左边必须是固定值，通配符只能出现在右边</strong>。select * from AAA where a like ‘1%’;会用到索引;而select * from AAA where a like ‘%1’;不会用到索引。</li>
<li><strong>索引前缀性的第三层意思：如果在字段前加了函数，则索引会被抑制</strong>，例如：select * from aaa where trim(a)=1,则不会用到索引。  <pre><code>在字段前嵌入了表达式，索引也将被抑制。假设a是date格式的，那么where a+7&lt;sysdate将不会用到索引，而where a&lt;sysdate-7会用到索引。    </code></pre>　还有两个特殊声明：  <pre><code>1). select * from AAA where a=:xxx and c=sysdate与 select * from AAA where c=sysdate and a=:xxx;都会用到索引，即与where语句中字段出现的顺序无关；   
2).select * from AAA where a=:xxx and b=1;会使用索引，此时A出现，即使其他字段不是索引字段也会使用到索引。</code></pre></li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm简述</title>
    <url>/2020/02/19/jvm/</url>
    <content><![CDATA[<p><strong>概述</strong><br>jvm是java中很重要的一块知识，也是面试常问的问题之一，今天笔者就带你深入了解一下jvm的知识，本文分以下几部分</p>
<ol>
<li>jvm的内存模型</li>
<li>jvm的垃圾回收机制及回收算法</li>
<li>jvm的常见参数</li>
<li>jvm的监控及调优<br>​​<a id="more"></a><h2 id="一、jvm内存模型"><a href="#一、jvm内存模型" class="headerlink" title="一、jvm内存模型"></a>一、jvm内存模型</h2><img src="https://img-blog.csdnimg.cn/20190414110612174.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUxNjc4OA==,size_16,color_FFFFFF,t_70" alt="jvm" title="jvm内存模型"></li>
</ol>
<p>上图即为jvm的内存模型示意图，jvm的主要分为堆、栈、方法区、程序计数器四部分。其中方法区和堆是线程共享的。栈、程序计数器是线程私有的。下面我将逐一解释这几个部分</p>
<p><strong>程序计数器</strong>：在多线程情况下，线程会根据时间片来抢夺CPU的资源。即便在多线程情况下，cpu也只会在同一时间执行一条语句，程序计数器即在每一个线程执行时记录其执行位置，以便被打断后能恢复至正确的位置执行。</p>
<p><strong>栈</strong>：栈里存储的都是<strong>局部变量</strong>，用以引用堆和方法区中的对象和常量。此处可抛出StackOverflowException和OutOfMemoryException（大多数–此处在《深入理解JVM虚拟机》中一书提到）</p>
<p><strong>堆</strong>：堆中存放的是<strong>对象的实例</strong>。绝大部分的对象实例在这里分配内存。堆可以处在物理不连续的内存空间上，只要逻辑上连续就可以。java堆在是实现时，可以是固定的，也可以是可扩展的（-Xmx 最大）（ -Xms最小）超过可扩展的最大大小时抛出OOM异常。堆的大小在理论上应不超过32G，一旦超过则jvm原有对堆的优化就会失效，在提升jvm大小时要考虑这个问题。</p>
<p><strong>方法区</strong>： 方法区中存放的都是<strong>常量和静态变量、被加载的类信息以及被即时编译器编译后的代码</strong>。方法区和永久带分别为jvm的规范和HotSpot虚拟机的具体实现。运行时常量池也是方法区的一部分。</p>
<p><strong>方法区的回收</strong>：主要是对常量池的回收及对类型的卸载。</p>
<p><strong>回收类</strong>：1、此类的所有实例已被回收。 2、此类的ClassLoader已被回收 3、此类在任何地方没有没反射引用</p>
<h2 id="二、jvm的垃圾回收机制及回收算法"><a href="#二、jvm的垃圾回收机制及回收算法" class="headerlink" title="二、jvm的垃圾回收机制及回收算法"></a>二、jvm的垃圾回收机制及回收算法</h2><p><strong>垃圾回收算法（*）</strong></p>
<p>垃圾回收的区域位于<strong>堆</strong></p>
<ul>
<li><p>引用计数法<br>循环引用</p>
</li>
<li><p>可达性分析<br>通过GCRoot向下查找，查找的路径称为引用链，一旦某个对象不处于引用链上，则该对象是不可用的。</p>
</li>
</ul>
<p>可作为GCRoot的对象：</p>
<ul>
<li><strong>虚拟机栈(栈帧中的局部变量表)中引用的对象</strong></li>
<li><strong>方法区中类静态属性引用的对象</strong></li>
<li><strong>方法区中常量引用的对象</strong></li>
<li><strong>本地方法栈中Native方法引用的对象</strong></li>
</ul>
<p><strong>标记—清除算法</strong><br>标记清除算法分为两个部分标记和清除</p>
<p>标记即从GCRoot开始标记存活对象，之后清除其他未被标记对象</p>
<p>效率问题：标记和清除两步的效率都不高</p>
<p>空间问题：标记—清除算法清理对象时并不会移动对象，所以在清除过后易产生大量不连续的内存碎片，在以后分配大对象时，由于连续空间不足会提前触发GC</p>
<p><strong>复制算法</strong><br>复制法即将目标内存区域分为两块，每次只使用其中一块，一块内存用完就将此块内存存活对象复制至另一块，再将此块内存清空。新生代的收集及采用此种算法，因为在新生代的对象存活率低。在jvm中将新生代分为<strong>较大Eden和两个较小的survivor空间</strong>。每次使用其中一块Eden和survivor，回收时将存活的放入另一块survivor中，再清理掉之前的。默认比例8:1:1。也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。survivor空间不够时，需要依赖其他内存（老年代）进行分配担保，即让对象进入老年代。</p>
<p><strong>新生代进入老生代的情况</strong></p>
<blockquote>
<ul>
<li>对象优先在Eden分配<strong>当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC</strong>，。现在的商业虚拟机一般都采用复制算法来回收新生代，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。 当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后处理掉Eden和刚才的Survivor空间。（HotSpot虚拟机默认Eden和Survivor的大小比例是8:1）<strong>当Survivor空间不够用时，需要依赖老年代进行分配担保。</strong></li>
<li><strong>大对象直接进入老年代</strong>。所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。<br>长期存活的对象(-XX:MaxTenuringThreshold)**将进入老年代。当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。</li>
<li>动态对象年龄判定。为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中<strong>相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象</strong>就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。   </li>
</ul>
</blockquote>
<p><strong>为什么分代收集</strong></p>
<ul>
<li>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率.<blockquote>
<p><strong>HotSpot算法实现</strong></p>
<ol>
<li>枚举根结点<br>GC Roots在全局性引用（常量或类静态属性）和执行上下文（栈帧的本地变量表）中，如果太多的话不可能一一进行检查，太消耗时间。同时，GC检查时会出现GC停顿，即可达&gt; 性分析工作必须在一个能确保一致性的快照中进行，此时在整个分析期间整个执行系统仿佛被冻结，对象的引用关系不会出现变化，否则分析结果无法保证。即GC进行时必须停&gt; 顿所有的Java执行线程。目前虚拟机使用的都是准确式GC（虚拟机自己知道内存中某个位置的具体数据是什么类型，即知道哪些地方存放着对象引用）。在类加载完成时，使用&gt; OopMap数据结构（OOP，普通对象指针）来进行查看对象的存放地址。GC扫描时就可以直接得到信息。</li>
<li>安全点<br>GC Roots枚举的问题：可能导致引用关系变化，或者说OopMap内容变化的指令非常多。如果每一条指定都生成OopMap，那将会需要大量的额外空间，GC的空间成本将会变很高。<br>安全点：没有每条指令都生成OopMap，只在特定位置记录了信息，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。由于安全点的选定既不能太&gt; 少以致于让GC等待时间太长，也不能太过于频繁以致于过分增大运行时的负荷。因此，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”来选定的。长时间运行即&gt; 指令序列复用，例如方法调用、循环跳转、异常跳转等。<br>另一个问题是如何在GC发生时让所有线程（不包括执行JNI调用的线程）都到最近的安全点上再停顿下来。<br>有两种方式：抢先式中断和主动式中断。<br>抢先式中断即不需要线程的先执行代码主动配合，而是在GC发生时，先全部中断，然后发现有线程中断的不在安全点上，就恢复线程，让其跑到安全点上再停顿。（几乎没用这种方&gt; 式。）<br>主动式中断： 当GC需要中断时，不直接对线程操作，仅仅简单设置一个标志，各线程主动去轮询这个标志，发现中断标志时就自己中断挂起。轮询标志的地方和安全点是重合的，&gt; 另外再加上创建对象需要分配内存的地方。</li>
<li>安全区域<br>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的安全点。但是对于不执行（即没有分配CPU时间）的程序，如线程处于sleep或Blocked状态，线程就无法响&gt; 应JVM的中断请求，走到安全点去挂起。JVM也不太可能等待线程重新被分配CPU时间。这时就需要安全区域来解决了。<br>安全区域即在一段代码片段中，引用关系不会发生变化。在这个区域任意地方开始GC都是安全的。可以看作是被扩展了的安全点。<br>线程到达安全区域时，先标识自己进入安全区域。当这段时间内JVM要发起GC时，就不用管标识安全区域状态的线程了。当线程要离开安全区域时，先检查系统是否完成了根结点枚&gt; 举或整个GC过程，完成了就继续执行，没有就等待直到收到可以安全离开安全区域的信号为止。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="内存分配担保机制"><a href="#内存分配担保机制" class="headerlink" title="内存分配担保机制"></a>内存分配担保机制</h3><pre><code>我们知道如果对象在复制到Survivor区时若Survivor空间不足，则会出发担保机制，将对象转入老年代；但老年代的能力也不是无限的，因此需要在minor GC时做一个是否需要Major GC 的判断：</code></pre><p>如果老年代的剩余空间 &lt; 之前转入老年代的对象的平均大小，则触发Major GC</p>
<p>如果老年代的剩余空间 &gt; 之前转入老年代的对象的平均大小，并且允许担保失败，则直接Minor GC，不需要做Full GC</p>
<p>如果老年代的剩余空间 &gt; 之前转入老年代的对象的平均大小，并且不允许担保失败，则触发Major GC</p>
<p>出发点还是尽量为对象分配内存。但是一般会配置允许担保失败，避免频繁的去做Full GC。</p>
<p><strong>标记—整理算法</strong><br>     标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法<strong>适用于对象存活率高的场景（老年代）。无内存碎片</strong></p>
<p><strong>新生代、老年代、永久代</strong></p>
<pre><code>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的. 如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。</code></pre><p>老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中<br>永久代主要用于存放静态文件，如Java类、方法等</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p> <img src="http://static.zybuluo.com/Rico123/9hswys8w1pqy0ch06vmlbqi2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="垃圾收集器" title="垃圾收集器"></p>
<ul>
<li><strong>Serial收集器（复制算法)</strong>: 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li><strong>Serial Old收集器 (标记-整理算法)</strong>: 老年代单线程收集器，Serial收集器的老年代版本；</li>
<li><strong>ParNew收集器 (复制算法)</strong>:新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li><strong>Parallel Scavenge收集器 (复制算法)</strong>: 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 =用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li><strong>Parallel Old收集器 (标记-整理算法)</strong>： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li><strong>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</strong>：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
<li><strong>G1(Garbage First)收集器 (标记-整理算法)</strong>：Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<p><strong>内存泄露问题</strong></p>
<ul>
<li><strong>静态集合类</strong>: 如 HashMap、Vector 等集合类的静态使用最容易出现内存泄露，因为这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放</li>
<li>各种资源连接包括<strong>数据库连接、网络连接、IO连接</strong>等没有显式调用close关闭</li>
<li><strong>监听器</strong>的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li>
</ul>
<h2 id="三、jvm的常见参数"><a href="#三、jvm的常见参数" class="headerlink" title="三、jvm的常见参数"></a>三、jvm的常见参数</h2><ul>
<li><p>-Xmx3550m：设置JVM最大堆内存为3550M。</p>
</li>
<li><p>-Xms3550m：设置JVM初始堆内存为3550M</p>
</li>
<li><p>-Xmn2g：设置年轻代大小为2G。</p>
</li>
<li><p>-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。</p>
</li>
<li><p>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。</p>
</li>
</ul>
<h2 id="四、jvm的监控及调优"><a href="#四、jvm的监控及调优" class="headerlink" title="四、jvm的监控及调优"></a>四、jvm的监控及调优</h2><p>jvm的监控与调优一方面依赖第三方工具，但更多的还是利用jdk中自带的一些工具</p>
<p>包括jmap，jstack，jconsole等</p>
<p> <strong>gc日志输出</strong></p>
<pre><code>在jvm启动参数中加入 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCApplicationStopedTime，jvm将会按照这些参数顺序输出gc概要信息，详细信息，gc时间信息，gc造成的应用暂停时间。如果在刚才的参数后面加入参数 -Xloggc:文件路径，gc信息将会输出到指定的文件中</code></pre>]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap原理解读</title>
    <url>/2019/04/03/hashMap/</url>
    <content><![CDATA[<p><strong>概述</strong><br>     Map是以key – value 结构存储数据（键值对映射），在java中Map是一个接口，其实现类包括但不限于HashMap（数组+链表/红黑树）、TreeMap（红黑树）、ConcurrentHashMap（cas并发）、HashTable（全局锁并发）、LinkedHashMap（链表）。hashmap是map的一种。</p>
<a id="more"></a>
<p><strong>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</strong></p>
<p>本文将着重介绍HashMap，大致分为三部分</p>
<ol>
<li>底层原理 及具体操作时HashMap的处理（基本属性、常量、resize操作等）</li>
<li>多线程下的问题。</li>
<li>基本api </li>
</ol>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p> HashMap 的底层是是用数组+链表，如图<br><img src='https://img-blog.csdn.net/20131105152215718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdmtpbmdfd2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast'></img></p>
<p>HashMap里的元素以Node（静态内部类）为单位，其中属性包含node的hash值，node的key、value及next</p>
<p><strong>注意：下列代码只为主要属性及构造函数，其余方法并未列出，不是没有</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">       final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           this.hash &#x3D; hash;</span><br><span class="line">           this.key &#x3D; key;</span><br><span class="line">           this.value &#x3D; value;</span><br><span class="line">           this.next &#x3D; next;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node根据key的hash值去确定Node在数组中所在位置，若此位置已有Node，则将新Node加入至链表尾部，当数组长度超过 <strong>MIN_TREEIFY_CAPACITY= 64</strong>  且单budget的长度超过 <strong>TREEIFY_THRESHOLD = 8</strong>  时此budget的链表转化为红黑树，当链表长度小于 <strong>UNTREEIFY_THRESHOLD = 6</strong> 时转为链表，HashMap的key值与value值均可为空，但只能有一个key值为空。当key值为空时，haah值为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int hashCode(Object o) &#123;</span><br><span class="line">      return o !&#x3D; null ? o.hashCode() : 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p> HashMap的默认长度及自定义长度均为2^n，即便自定义长度不为2^n，hashMap也会优化为2^n，hashMap的实际容量计算函数为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line"></span><br><span class="line">        int n &#x3D; cap - 1;</span><br><span class="line">       &#x2F;&#x2F;设n为1xxxxxxxx（8位）</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">        &#x2F;&#x2F; n &#x3D; 11xxxxxxx</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">        &#x2F;&#x2F; n &#x3D; 1111xxxxx</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">        &#x2F;&#x2F; n &#x3D; 11111111x</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">        &#x2F;&#x2F; n &#x3D; 111111111</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">        &#x2F;&#x2F; n &#x3D; 111111111</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">        &#x2F;&#x2F; n &#x3D; 1000000000(9位)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>HashMap之所以要将table长度设为2^n是为了能更好的利用table空间，减少hash冲突，运算更快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;tablelen-1 末尾为1 进行&amp;操作时会更利于index分散</span><br><span class="line">index &#x3D; （table.length - 1） &amp; hash(key);</span><br></pre></td></tr></table></figure>

<img src='https://img-blog.csdnimg.cn/20190411163557709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUxNjc4OA==,size_16,color_FFFFFF,t_70'/>


<p><strong>resize</strong>    </p>
<p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。    </p>
<p>   那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16</em>0.75=12的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
<h2 id="并发操作问题"><a href="#并发操作问题" class="headerlink" title="并发操作问题"></a>并发操作问题</h2><p>一、死循环</p>
<p>在jdk1.8之前，resize操作时，当两个线程同时触发resize操作，基于头插法可能会导致链表节点的循环引用，在下次调用get操作查找一个不存在的key时，会在循环链表中出现死循环。</p>
<p>在jdk1.8中，在插入时，声明两对指针，维护两个连链表，依次在末端添加新的元素。（在多线程操作的情况下，无非是第二个线程重复第一个线程一模一样的操作），因而不再有多线程put导致死循环，但是依然有其他的弊端，比如数据丢失（与内存可见性有关）或size不准确。因此多线程情况下还是建议使用concurrenthashmap。</p>
<p>二·、fail-fast</p>
<p>hashMap用modCount来维护修改次数，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，将抛出ConcurrentModificationException，这就是所谓fail-fast策略。、</p>
<p>注意到modCount声明为volatile，保证线程之间修改的可见性。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><img src='https://img-blog.csdnimg.cn/20190411164619990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDUxNjc4OA==,size_16,color_FFFFFF,t_70' />


]]></content>
      <tags>
        <tag>java</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
</search>
